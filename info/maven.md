Maven - program that compiles and builds you project. You can build your java code from console, via IDEA, or via some
helper program like Ant, Maven, or Gradle.

Many projects are using maven as a build tool, and it needs some configuration for itself. To not create this structure
by yourself, we can use mvn to generate a project.
Maven parses settings file, understands what is going on and passes control to his plugins.

```shell script
mvn archetype:generate;
```

groupId - url of your company. For example if it would google - it would be "com.google".
artifactId - name of your project.
version
Those properties are uniq identifiers for you project.

pom.xml - file with maven settings.

After project structure with simple code is generated we can compile it from root folder. 
```shell script
mvn compile;
mvn test; #to run the tests
mvn package; #to create a jar file
java -cp target/my_jar_file.jar com.olehbondaruk.App
         #class pass            #what class I want to run    
```

src/main/java - for app code
src/main/resources - for media, html, and other data
src/main/test - for tests

You can run a maven plugin with some goal separately.
```shell script
mvn compiler:compile # compiler plugin makes compile goal
mvn help:describe -Dplugin=surefire # "help" plugin with "describe" goal (-D arguments) will try to find surefire plugin
# and get info about it. Also here you can find the goals of the plugin.
mvn help:describe -Dplugin=surefire -Dgoal=test #get the info about surefire test goal. (some time need -Dmojo=test ?)
```

The surefire plugin is responsible for testing.

Maven lifecycle - set of plugins that run in once, one after another.

default - handles your project deployment
    validate - validate the project is correct and all necessary information is available.
    initialize - initialize build state, e.g. set properties or create directories.
    generate-sources - generate any source code for inclusion in compilation.
    process-sources - process the source code, for example to filter any values.
    generate-resources - generate resources for inclusion in the package.
    process-resources - copy and process the resources into the destination directory, ready for packaging.
    compile - compile the source code of the project.
    process-classes - post-process the generated files from compilation, for example to do bytecode enhancement on Java 
        classes.
    generate-test-sources - generate any test source code for inclusion in compilation.
    process-test-sources - process the test source code, for example to filter any values.
    generate-test-resources - create resources for testing.
    process-test-resources - copy and process the resources into the test destination directory.
    test-compile - compile the test source code into the test destination directory
    process-test-classes - post-process the generated files from test compilation, for example to do bytecode 
        enhancement on Java classes.
    test - run tests using a suitable unit testing framework. These tests should not require the code be packaged or 
        deployed.
    prepare-package - perform any operations necessary to prepare a package before the actual packaging. This often 
        results in an unpacked, processed version of the package.
    package - take the compiled code and package it in its distributable format, such as a JAR.
    pre-integration-test - perform actions required before integration tests are executed. This may involve things 
        such as setting up the required environment.
    integration-test - process and deploy the package if necessary into an environment where integration tests can be run.
    post-integration-test - perform actions required after integration tests have been executed. This may including 
        cleaning up the environment.
    verify - run any checks to verify the package is valid and meets quality criteria.
    install - install the package into the local repository, for use as a dependency in other projects locally.
    deploy - done in an integration or release environment, copies the final package to the remote repository for 
        sharing with other developers and projects.
clean - handles project cleaning
    pre-clean - execute processes needed prior to the actual project cleaning
    clean - remove all files generated by the previous build
    post-clean - execute processes needed to finalize the project cleaning
site - handles the creation of your project's site documentation.
    pre-site - execute processes needed prior to the actual project site generation
    site - generate the project's site documentation
    post-site - execute processes needed to finalize the site generation, and to prepare for site deployment
    site-deploy - deploy the generated site documentation to the specified web server.

So all job is done with plugins, e.g. to copy resources to target, and compile java code - we need something like: 
```shell script
mvn resources:resources compiler:compile surefire:test
```
But this is too long, so instead you just type.
```shell script
mnv compile test
```
And all these plugins is run one after another.
NOTE: if you run the "compile" default lifecycle step, that means maven will run all previous to compile steps like
initialize, generate, ... process-resources.

maven_folder/lib/maven-model-builder-3.6.3 - here is a super POM, basic pom.xml. And all your settings that you've
added in your project pom.xml - is overriding setting from a basic pom.xml.
The effective pom - it's a mix from super POM and your project's pom.xml.

```shell script
mvn help:effective-pom; # will show current state of your pom.xml
``` 

```xml
<myProperty>My_Property_value</myProperty>
<version>${project.myProperty}-beta</version>
```
You can get some properties of your project with template string syntax ${}.

Same story with env vars, we can get the value typing property name.
```xml
<version>${MY_ENV_VAR}-beta</version>
```

Or you can rely on some env var using env reference
```xml
<version>${env.MY_ENV_VAR}-beta</version>
```

Also, we have settings reference.
<version>${settings.offline}-beta</version>

Your properties you need to add in properties section:
```xml
<project>
    <properties>
        <myProp>123</myProp>
    </properties>

    <version>${myProp}-beta</version>
</project>
```
All compiled properties you can find in target/maven-archiver/pom.properties 

Some settings in pom.xml don't have serious impact, and cary only informative sense.
name, url, organization, developer, timezone, email, id, role, licence, distribution...

Dependencies.
Before the maven - you needed to download locally all dependencies for your project, which was not effective.
Maven can manage it for you. All popular dependency maven stores on his repository (like npm) in .jar files.
All dependencies in the repository, same as you project has coordinates, identification:
groupId (backwards url), artifactId (name of dependency), and version. With this you can add package you want to 
your project with a pom.xml
 
e.g. I want to use a logger in my code.
I need to add dependencies section to pom.
```xml
<dependencys>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.13.2</version>
        <!--<package>war/zip/jar</package> not necessary but you can change type of package you want to include-->
        <!--<optional>true</optional> also we have ability to make dependency optional -->
    </dependency>
</dependencys>
```

Then I have ability to use
```java
import org.apache.logging.log4j.Logger;
public class App {
    Logger logger = Logger.getLogger(App.class); 
    public static void main(String[] args) {
        System.out.println("Ahh... shi... here we go again.");
        logger.debug("Hello from logger!");
    }
}
```

All dependencies (packages) lies globally in ~/.m2/repository (like global node modules in ~/AppData/Roaming (win))
maven plugins also in this folder.
All packages are in a hierarchy groupId > artifactId > version.

You have ability to add optional dependency.
For example there is a big project (or yours), with a lot of functionality, and developers decided that not all
functionality of this project will often be used, or they force user of their project to use his implementation of some
module, and for some specific functionality - they make dependencies optional.
When someone will add this project to his pom as a dependency, maven automatically install all not-optional dependencies
from his repo, and optional won't be installed.
When you will use this specific functionality - you'll need to add dependency to your pom with your hands.
Something like peer dependency in npm, it assumes that you have this already in your local .m2 folder, or you need to 
add it.

Dependency versioning.
( - this brace means from this version but not include it. 
[ - this brace means from this version but include it as well.
```xml
<project>
    <version>(1.2,1.5)</version> <!-- means you can use 1.3, 1.4 -->
    <version>[1.2,1.5)</version> <!-- means you can use 1.2, 1.3, 1.4 -->
    <version>(1.2,1.5]</version> <!-- means you can use 1.3, 1.4, 1.5 -->
    <version>[1.2,1.5]</version> <!-- means you can use 1.2, 1.3, 1.4, 1.5 -->
    <version>[1.2,]</version> <!-- means you can use 1.2 and all further -->
    <version>[,1.5)</version> <!-- means you can use all versions before 1.2 -->
    <version>(,1.5)</version> <!-- not valid (?) -->
</project>
``` 

Transitive Dependencies, also help when there is cycle dependency in your dependencies:
```shell script
 mvn dependency:resolve #will check for dependency
 mvn dependency:tree #will print dependency as tree (like npm ls with depth)
 mvn dependency:analyze #will print statistic about your dependencies
```

When a few of your dependencies using different version of same package, and you want to exclude one of it
you can in dependency tag in your pom add exclusions tag and type ID of needed package to exclude.

from dependency tree we know
[INFO] +- junit:junit:jar:4.11:test
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test

I want to exclude hamcrest
my pom:
```xml
    <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
          <version>4.11</version>
          <scope>test</scope>
          <exclusions>
            <exclusion>
              <groupId>org.hamcrest</groupId>
              <artifactId>hamcrest-core</artifactId>
            </exclusion>
          </exclusions>
        </dependency>
```
and we get:
[INFO] +- junit:junit:jar:4.11:test
without hamcrest.
After you exclude something you don't want - you can add needed one as a regular dependency.

Modules.
Every big project contain from small projects, modules. If we are adding new module to parent project, then in parent
and child pom will be added:
```xml
  <!-- Parent pom -->
  <modules>
    <module>Sub_project</module>
  </modules>

  <!-- Child pom -->
  <parent>
     <artifactId>maven_stuff</artifactId>
     <groupId>com.olehbondaruk</groupId>
     <version>1.0</version>
  </parent>
  <artifactId>Sub_project</artifactId> <!-- In child module only project name is changed by default, but you can change more--> 
```
Child will inherit all setting from parent, same as all poms inherited settings from super maven pom and can override
them. Also, if project has a lot of modules, and you don't need all of them - we can build modules separately with
the maven, via a tool window in IDEA, or via terminal in root folders of submodules.

Dependency management.
For example in your project there are two sub projects (modules), each of the added different version of junit to his
dependency. To solve this you can add dependency management to your main pom and tell set the version there, after this
in all sub modules you can set only groupId and artifactId of the dependency, version will be set from parent pom 
automatically.


Exec plugin
Run code not via java -cp ./my_app.jar com.oleh.App App but via maven exec plugin
```shell script
mvn exec:java -Dexec.mainClass=Main
```
Jetty plugin
To run web application - you need to run .war file, and you can serve it with tomcat server, and check it out on 
localhost. To avoid run a heavy tomcat - you can use the jetty plugin.

Add jetty to plugins
```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.eclipse.jetty</groupId>
                <artifactId>jetty-maven-plugin</artifactId>
                <version>9.4.28.v20200408</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <version>3.2.0</version>
                <configuration>
                    <webXml>${project.basedir}\src\main\webapp\WEB-INF\web.xml</webXml>
                </configuration>
            </plugin>
        </plugins>
 </build>
```
And you can run tasks in maven tool window > plugins > jetty
Also you can run it via a console $> mvn jetty:run

Maven profiles
To run application in different environments, e.g. dev and prod.
And you'll see profiles section in maven tool window.
Also, we can use terminal: mvn clean package -Pdev (-P - for profile)
We can add profiles in pom
```xml
    <profiles>
        <profile>
            <id>dev</id>
            <properties>
                <run_port>3000</run_port>
            </properties>
        </profile>
        <profile>
            <id>prod</id>
            <properties>
                <run_port>4000</run_port>
            </properties>
        </profile>
    </profiles>
```
Or we can create file profiles.xml in project root folder:
```xml
<profilesXml xmlns="http://maven.apache.org/PROFILES/1.0.0">
    <profiles>
        <profile>
    <!--activation optional, if you want to run it depend on environment variable env=dev
            <activation> 
                <property>
                    <name>env</name>
                    <value>dev</value>
                </property>
            </activation> -->
            <id>dev</id>
            <properties>
                <run_port>3000</run_port>
            </properties>
        </profile>
    </profiles>
</profilesXml>
```
Or we can add them in ~/settings.xml:
```xml
<settings>
    <profiles>
        <profile>
            <id>dev</id>
            <properties>
                <run_port>3000</run_port>
            </properties>
        </profile>
    </profiles>
</settings>
```
IDEA will complain that in pom it cannot resolve variables (from ~/setting), but build will be ok.
activation - tag helps to activate needed profile depends on environment where program starts.
```xml
<activation>
        <activeByDefault/>
        <jdk/> <!-- depends on JDK version -->
        <os> <!-- depends on OS -->
          <name/>
          <family/>
          <arch/>
          <version/>
        </os>
        <property> <!-- if property with some name equals value -> profile will be activated -->
          <name/>
          <value/>
        </property>
        <file> <!-- depends on existing or messing file -->
          <missing/>
          <exists/>
        </file>
      </activation>
```
Filtering resources
When you want to give ability user of your project customize some properties - you can add in resources
folder something with contend depend on your pom properties tags. Like some texts file with:
```text
dbPassword=${db.pass}
```
in pom:
```xml
<properties>
  <db.pass>1234</db.pass>
</properties>
...
<build>
    <resources>
       <resource>
       <directory>${basedir}\src\main\resources</directory>
          <filtering>true</filtering>
       </resource>
    </resources>
</build>
```
That gives ability to change dbPassword=${db.pass} to dbPassword=1234 in that text file.
Or pass it during the recources phase
```shell script
mvn resources:resources -Ddb.pass="1234"
```

