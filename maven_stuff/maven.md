## Maven
You can build your java code from console, via IDE, or via some helper program like Ant, Maven, or Gradle.

Maven simplifies the build process by providing a uniform build system and a project management framework, handles project
dependencies, lifecycle, and builds, making it easier to manage and deploy Java projects.

Many projects are using maven as a build tool, and it needs some configuration for itself. To not create this structure
by yourself, we can use `mvn` to generate a project.
Maven parses settings file, understands what is going on and passes control to his plugins.

```shell script
mvn archetype:generate;
```

POM (Project Object Model) is a corner settings file for maven. \
It contains some key elements:
- GroupId, ArtifactId, Version:
These elements `groupId, artifactId, and version` uniquely identify the project. For example, `com.example:my-app:1.0-SNAPSHOT`
- Packaging:
Specifies that the project will be packaged as a JAR file.
- Dependencies:
This project depends on JUnit for testing. The scope is set to test, meaning JUnit is only used during testing.
- Build and Plugins:
Configures the maven-compiler-plugin to use Java 1.8 for source and target compilation.

After project structure with simple code is generated we can compile it from root folder.
```shell script
mvn clean install
```
When you combine `clean` and `install`, Maven first cleans up the previous build artifacts and then runs through the
entire build lifecycle up to the `install` phase.

### Maven Lifecycle Phases
Maven defines a series of build phases, each representing a step in the build lifecycle. When you run mvn install, Maven
executes all phases up to and including install in the following order:
- validate: Checks if the project is correct and all necessary information is available.
- compile: Compiles the source code of the project.
- test: Runs tests using a suitable testing framework (e.g., JUnit).
- package: Packages the compiled code into a distributable format, such as a JAR or WAR file.
- verify: Runs any checks to ensure the package is valid and meets quality criteria.
- install: Installs the package into the local repository (default `~/.m2/repository`) for use as a dependency in other
projects.



Maven lifecycle - set of plugins that run in once, one after another:
- default - handles your project deployment
- **validate** - validate the project is correct and all necessary information is available.
- initialize - initialize build state, e.g. set properties or create directories.
- generate-sources - generate any source code for inclusion in compilation.
- process-sources - process the source code, for example to filter any values.
- generate-resources - generate resources for inclusion in the package.
- process-resources - copy and process the resources into the destination directory, ready for packaging.
- **compile** - compile the source code of the project.
- process-classes - post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.
- generate-test-sources - generate any test source code for inclusion in compilation.
- process-test-sources - process the test source code, for example to filter any values.
- generate-test-resources - create resources for testing.
- process-test-resources - copy and process the resources into the test destination directory.
- test-compile - compile the test source code into the test destination directory
- process-test-classes - post-process the generated files from test compilation, for example to do bytecode enhancement
on Java classes.
- **test** - run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.
- prepare-package - perform any operations necessary to prepare a package before the actual packaging. This often 
results in an unpacked, processed version of the package.
- **package** - take the compiled code and package it in its distributable format, such as a JAR.
- pre-integration-test - perform actions required before integration tests are executed. This may involve things
such as setting up the required environment.
- integration-test - process and deploy the package if necessary into an environment where integration tests can be run.
- post-integration-test - perform actions required after integration tests have been executed. This may include
  cleaning up the environment.
- **verify** - run any checks to verify the package is valid and meets quality criteria.
- **install** - install the package into the local repository, for use as a dependency in other projects locally.
- **deploy** - done in an integration or release environment, copies the final package to the remote repository for
sharing with other developers and projects.
- **clean** - handles project cleaning
- pre-clean - execute processes needed prior to the actual project cleaning
- clean - remove all files generated by the previous build
- post-clean - execute processes needed to finalize the project cleaning
- site - handles the creation of your project's site documentation.
- pre-site - execute processes needed prior to the actual project site generation
- site - generate the project's site documentation
- post-site - execute processes needed to finalize the site generation, and to prepare for site deployment
- site-deploy - deploy the generated site documentation to the specified web server.

### Dependency Management
Dependency system allows you to easily include external libraries (dependencies) in your project. Maven handles downloading
these libraries, managing version conflicts, and resolving transitive dependencies.

`<dependencies>` -> `<dependency>` containing `groupId, artifactId, version`.

Before the maven - you needed to download locally all dependencies for your project, which was not effective.
All popular dependency maven stores on his repository (like npm) in .jar files.
All dependencies in the repository, same as you project has coordinates, identification:
groupId (backwards url), artifactId (name of dependency), and version. With this you can add package you want to
your project with a pom.xml

e.g. I want to use a logger in my code. I need to add dependencies section to pom.
```xml
<dependencys>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.13.2</version>
        <!--<package>war/zip/jar</package> not necessary but you can change type of package you want to include-->
        <!--<optional>true</optional> also we have ability to make dependency optional -->
    </dependency>
</dependencys>
```

Then I have ability to use
```java
import org.apache.logging.log4j.Logger;
public class App {
    Logger logger = Logger.getLogger(App.class); 
    public static void main(String[] args) {
        System.out.println("Ahh... shi... here we go again.");
        logger.debug("Hello from logger!");
    }
}
```

All dependencies (packages) lies globally in _~/.m2/repository_ (like global node modules in _~/AppData/Roaming_ (win))
maven plugins also in this folder. \
All packages are in a hierarchy _groupId > artifactId > version_.

#### Dependency versioning
( - this brace means from this version but not include it.
[ - this brace means from this version but include it as well.
```xml
<project>
  <version>(1.2,1.5)</version> <!-- means you can use 1.3, 1.4 -->
  <version>[1.2,1.5)</version> <!-- means you can use 1.2, 1.3, 1.4 -->
  <version>(1.2,1.5]</version> <!-- means you can use 1.3, 1.4, 1.5 -->
  <version>[1.2,1.5]</version> <!-- means you can use 1.2, 1.3, 1.4, 1.5 -->
  <version>[1.2,]</version> <!-- means you can use 1.2 and all further -->
  <version>[,1.5)</version> <!-- means you can use all versions before 1.2 -->
  <version>(,1.5)</version> <!-- not valid (?) -->
</project>
```

#### Dependency Scopes
Scopes control the classpath of the various build tasks and specify when the `dependency` is included in the classpath:

The `classpath` is a parameter in the JVM and the Java compiler that specifies the location of user-defined classes and
packages. It's essentially a list of directories, JAR files, and ZIP files where the JVM looks for classes and resources
when running Java programs.

- compile (default):
Available in all classpaths (`compile`, `test`, `runtime`). Included in the final artifact. 
- provided:
Available in `compile` and `test` classpaths but not `runtime`. Not included in the _final artifact_ (e.g., servlet API).
- runtime:
Not available in the `compile` classpath. Available in `runtime` and `test` classpaths. Included in the _final artifact_ (e.g., JDBC driver).
- test:
Only available in the `test` classpath. Not included in the _final artifact_ (e.g., testing frameworks).
- system:
Similar to `provided` but requires an explicit path to the JAR on the local file system. _Should be **avoided** if possible._

You can run a maven plugin with some goal separately.
```shell script
mvn compiler:compile # compiler plugin makes compile goal
mvn help:describe -Dplugin=surefire # "help" plugin with "describe" goal (-D arguments) will try to find surefire plugin
# and get info about it. Also here you can find the goals of the plugin.
mvn help:describe -Dplugin=surefire -Dgoal=test #get the info about surefire test goal. (some time need -Dmojo=test ?)
```

#### Transitive Dependencies
Maven automatically includes transitive dependencies. If your project depends on Library A, and Library A depends on
Library B, Maven will include Library B in your project.

Transitive Dependencies, also help when there is cycle dependency in your dependencies:
```shell script
 mvn dependency:resolve #will check for dependency
 mvn dependency:tree #will print dependency as tree (like npm ls with depth)
 mvn dependency:analyze #will print statistic about your dependencies
```

#### Managing Dependency Conflicts
When multiple versions of the same dependency are included (directly or transitively), Maven uses the nearest-wins
strategy to resolve conflicts. If conflicts arise, you can explicitly specify the version you want to use or exclude
the unwanted version.

You have ability to add optional dependency \
For example there is a big project, with a lot of functionality, and developers decided that not all functionality of
this project will often be used, or they force user of their project to use his implementation of some module, and for
some specific functionality - they make dependencies optional. \
When someone will add this project to his _pom_ as a dependency, maven automatically install all not-optional dependencies
from his repo, and optional won't be installed. \
When you will use this specific functionality - you'll need to add dependency to your _pom_ with your hands. Something
like peer dependency in npm, it assumes that you have this already in your local _.m2_ folder, or you need to add it.

When a few of your dependencies using different version of same package, and you want to exclude one of it you can in
dependency tag in your pom add exclusions tag and type ID of needed package to exclude. \
From dependency tree we know
```text
[INFO] +- junit:junit:jar:4.11:test 
[INFO] |  \- org.hamcrest:hamcrest-core:jar:1.3:test
```

I want to exclude _hamcrest_. My pom:
```xml
    <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
          <version>4.11</version>
          <scope>test</scope>
          <exclusions>
            <exclusion>
              <groupId>org.hamcrest</groupId>
              <artifactId>hamcrest-core</artifactId>
            </exclusion>
          </exclusions>
        </dependency>
```
and we get:
```text
[INFO] +- junit:junit:jar:4.11:test
```
without hamcrest. \
After you exclude something you don't want - you can add needed one as a regular dependency.

### Plugins and Goals
Maven plugins are a core feature of Maven that provide the ability to extend and customize the build process. Each _plugin_
has specific _goals_, which are individual tasks that the plugin can execute. Goals can be bound to different phases of
the build lifecycle to automate a wide range of tasks such as compiling code, running tests, packaging artifacts,
deploying applications, and more.

#### Common Maven Plugins
- Maven `Compiler` Plugin:
Used to compile the project's source code. Goals: `compile`, `testCompile`.
- Maven `Surefire` (responsible for testing) Plugin:
Used to run unit tests. Goals: `test`.
- Maven `JAR` Plugin:
Used to create a JAR file from the project's compiled classes. Goals: `jar`.
- Maven `Install` Plugin:
Used to install the project's artifact into the local repository. Goals: `install`.
- Maven `Deploy` Plugin:
Used to deploy the project's artifact to a remote repository. Goals: `deploy`.

So all job is done by plugins, e.g. to copy resources to target, and compile java code - we need something like: 
```shell script
mvn resources:resources compiler:compile surefire:test
```
But this is too long, so instead you just type.
```shell script
mnv compile test
```
And all these plugins is run one after another.

> NOTE: if you run the `compile` default lifecycle step, that means maven will run all previous to compile steps like
initialize, generate, ... process-resources.

#### Custom Plugin Goals and Binding
You can also bind plugin goals to specific phases of the build lifecycle. This allows you to automate the execution of
these goals as part of the standard build process. \
In this example, the `clean` goal of the _maven-clean-plugin_ is explicitly bound to the `clean` phase of the build lifecycle.
```xml
  <build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-clean-plugin</artifactId>
      <version>3.1.0</version>
      <executions>
        <execution>
          <id>custom-clean</id>
          <phase>clean</phase>
          <goals>
            <goal>clean</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>
```

### Maven Repositories
Maven repositories are locations where Maven stores and retrieves project artifacts (JARs, POMs, etc.). These repositories
are essential for _dependency management_, allowing Maven to download the dependencies required by your project and to
upload artifacts produced by your project.

Types of Repositories:
- Local Repository. A local directory on your machine where _Maven_ stores downloaded artifacts and built projects.
Default location: _~/.m2/repository_ on Unix-based systems or _C:\Users\<your-username>\.m2\repository_ on Windows.
Artifacts are stored here after the first download, speeding up subsequent builds.
- Central Repository. A large public repository maintained by the Maven community. Default repository from which Maven
downloads dependencies if they are not found in the local repository. URL: https://repo.maven.apache.org/maven2
- Remote Repositories. Additional repositories specified in your pom.xml or settings.xml file. Used for retrieving
dependencies or deploying artifacts to a remote server.

#### Configuring Repositories
Repositories are configured in the _pom.xml_ file or the _settings.xml_ file.

### Effective POM
The effective POM is the result of merging your project's pom.xml with the super POM and other parent POMs. This merged
POM includes all inherited configurations, making it a comprehensive representation of the project's build configuration.

maven_folder/lib/maven-model-builder-3.6.3 - here is a super POM, basic pom.xml. And all your settings that you've
added in your project pom.xml - is overriding setting from a basic pom.xml.
The effective pom - it's a mix from super POM and your project's pom.xml.

```shell script
mvn help:effective-pom; # will show current state of your pom.xml
``` 

### Build Profiles
Build profiles in Maven allow you to customize the build process for different environments, conditions, or requirements.
By defining profiles, you can tailor dependencies, plugins, properties, and other configurations dynamically _based on_ 
certain criteria such as the active profile, operating system, or _specific properties_.

#### Defining Profiles
Profiles are defined in the _pom.xml_ file within the <profiles> element. Each profile is defined with a unique identifier
and can include its own set of configurations.

In this example, a dev profile is defined with specific properties, dependencies, and plugin configurations that are only
active when the `dev` profile is activated.
Profiles can be added to pom.xml:
```xml
<profiles>
    <profile>
        <id>dev</id>
        <properties>
            <env>development</env>
            <run_port>3000</run_port>
        </properties>
        <dependencies>
            ...
        </dependencies>
        <build>
            <plugins>
                ...
            </plugins>
        </build>
    </profile>
    <profile>
        <id>prod</id>
        <properties>
          <env>production</env>
          <run_port>4000</run_port>
        </properties>
    </profile>
</profiles>
```

Or in settings.xml. \
Or we can create file profiles.xml in project root folder:
```xml
<profilesXml xmlns="http://maven.apache.org/PROFILES/1.0.0">
    <profiles>
        <profile>
    <!--activation optional, if you want to run it depend on environment variable env=dev
            <activation> 
                <property>
                    <name>env</name>
                    <value>dev</value>
                </property>
            </activation> -->
            <id>dev</id>
            <properties>
                <run_port>3000</run_port>
            </properties>
        </profile>
    </profiles>
</profilesXml>
```

#### Activating Profiles
Profiles can be activated in several ways:
```xml
<activation>
        <activeByDefault/>
        <jdk/> <!-- depends on JDK version -->
        <os> <!-- depends on OS -->
          <name/>
          <family/>
          <arch/>
          <version/>
        </os>
        <property> <!-- if property with some name equals value -> profile will be activated -->
          <name/>
          <value/>
        </property>
        <file> <!-- depends on existing or messing file -->
          <missing/>
          <exists/>
        </file>
</activation>
```

1. Command Line:
  ```shell
  mvn clean install -Pdev
  ```
2. Settings File:
```xml
<settings>
    <profiles>
        <profile>
            <id>dev</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
        </profile>
    </profiles>
    <activeProfiles>
        <activeProfile>dev</activeProfile>
    </activeProfiles>
</settings>
```
3. Environment Variables:
```xml
<profiles>
    <profile>
        <id>prod</id>
        <activation>
            <property>
                <name>env</name>
                <value>production</value>
            </property>
        </activation>
        <!-- Profile configurations -->
    </profile>
</profiles>
```
You can set the environment variable and then run Maven:
```shell
export env=production
mvn clean install
```

### Multi-module Projects
A multi-module project is a project that is made up of multiple subprojects (or modules). Each subproject has its own
_pom.xml_ file, but there's also a parent project with its own _pom.xml_ that manages the overall structure and 
configuration of the subprojects.

```text
parent-project
│
├── pom.xml
├── module1
│   └── pom.xml
├── module2
│   └── pom.xml
└── module3
    └── pom.xml
```
Parent pom has a `<modules>` section, child pom has a `<parent>` section.

Modules. Every big project contain from small projects, modules. If we are adding new module to parent project, then 
in parent and child pom will be added:

```xml
  <!-- Parent pom -->
  <modules>
    <module>Sub_project</module>
  </modules>

  <!-- Child pom -->
  <parent>
     <artifactId>maven_stuff</artifactId>
     <groupId>com.olehbondaruk</groupId>
     <version>1.0</version>
  </parent>
  <artifactId>Sub_project</artifactId> <!-- In child module only project name is changed by default, but you can change more--> 
```
Child will inherit all setting from parent, same as all poms inherited settings from super maven pom and can override
them. Also, if project has a lot of modules, and you don't need all of them - we can build modules separately with the
maven, via a tool window in IDEA, or via terminal in root folders of submodules.

For example in your project there are two sub projects (modules), each of the added different version of junit to his
dependency. To solve this you can add dependency management to your main pom and tell set the version there, after this
in all sub modules you can set only groupId and artifactId of the dependency, version will be set from parent pom
automatically.

### Unit Tests with Maven Surefire Plugin
The Maven Surefire Plugin is used for running unit tests. By default, it looks for test classes in the _src/test/java_
directory and executes any methods annotated with testing frameworks like JUnit or TestNG.

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-surefire-plugin</artifactId>
  <version>3.0.0-M5</version>
  <configuration>
    <includes>
      <include>**/*Test.java</include>
    </includes>
    <!--    parallel test execution-->
    <parallel>classes</parallel>
    <threadCount>4</threadCount>
  </configuration>
</plugin>
```

### Integration Tests with Maven Failsafe Plugin
The Maven Failsafe Plugin is designed for running integration tests. It is typically used in the integration-test and
verify phases of the Maven build lifecycle. \
Failsafe expects integration test classes to follow a specific naming convention, typically ending with IT (e.g., MyClassIT.java).
```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-failsafe-plugin</artifactId>
      <version>3.0.0-M5</version>
        <executions>
          <execution>
            <goals>
              <goal>integration-test</goal>
              <goal>verify</goal>
            </goals>
          </execution>
        </executions>
</plugin>
```


#### Diff
You can get some properties of your project with template string syntax ${}.
```xml
<myProperty>My_Property_value</myProperty>
<version>${project.myProperty}-beta</version>
```

Same story with env vars, we can get the value typing property name.
```xml
<version>${MY_ENV_VAR}-beta</version>
```

Or you can rely on some env var using env reference
```xml
<version>${env.MY_ENV_VAR}-beta</version>
```

Also, we have settings reference.
```xml
<version>${settings.offline}-beta</version>
```

Your properties you need to add in properties section:
```xml
<project>
    <properties>
        <myProp>123</myProp>
    </properties>

    <version>${myProp}-beta</version>
</project>
```
All compiled properties you can find in _target/maven-archiver/pom.properties_ 

Some settings in _pom.xml_ don't have serious impact, and cary only informative sense. Things like: name, url,
organization, developer, timezone, email, id, role, licence, distribution...


Exec plugin
Run code not via java -cp ./my_app.jar com.oleh.App App but via maven exec plugin
```shell script
mvn exec:java -Dexec.mainClass=Main
```

Jetty plugin
To run web application - you need to run .war file, and you can serve it with tomcat server, and check it out on 
localhost. To avoid run a heavy tomcat - you can use the jetty plugin.

Add jetty to plugins
```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.eclipse.jetty</groupId>
                <artifactId>jetty-maven-plugin</artifactId>
                <version>9.4.28.v20200408</version>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-war-plugin</artifactId>
                <version>3.2.0</version>
                <configuration>
                    <webXml>${project.basedir}\src\main\webapp\WEB-INF\web.xml</webXml>
                </configuration>
            </plugin>
        </plugins>
 </build>
```
And you can run tasks in maven tool window > plugins > jetty
Also you can run it via a console $> mvn jetty:run


Filtering resources \
When you want to give the ability for a user of your project to customize some properties - you can add in _resources_
folder something content dependent on your _pom_ properties section. Like some texts file with:
```text
dbPassword=${db.pass}
```
in pom:
```xml
<properties>
  <db.pass>1234</db.pass>
</properties>
...
<build>
    <resources>
       <resource>
       <directory>${project.basedir}\src\main\resources</directory>
          <filtering>true</filtering>
       </resource>
    </resources>
</build>
```
That gives the ability to change _dbPassword=${db.pass}_ to _dbPassword=1234_ in that text file. Or pass it during the
_resources_ phrase.
```shell script
mvn resources:resources -Ddb.pass="1234"
```

Predefined maven variables: \
_${project.basedir}_ is the root directory of your project. \
_${project.build.directory}_ is equivalent to _${project.basedir}/target_ 

